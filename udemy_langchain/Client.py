# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/client/client.ipynb.

# %% auto 0
__all__ = ['Auth', 'ResponseGetData', 'get_cache', 'update_cache', 'get_data']

# %% ../nbs/client/client.ipynb 3
from typing import Any, Union
from dataclasses import dataclass, field
from abc import abstractmethod, ABC

import httpx
import json

# %% ../nbs/client/client.ipynb 5
@dataclass
class Auth(ABC):
    """Base class for authentication"""

    @abstractmethod
    def get_auth_headers(self) -> dict:
        """Get the headers for the authentication"""
        pass

# %% ../nbs/client/client.ipynb 7
@dataclass
class ResponseGetData:
    is_from_cache: bool
    is_success: bool
    status: int
    response: Any
    auth: Any = field(repr=False, default=None)

    @classmethod
    def _from_httpx(cls, response: httpx.Response, auth: Any = None):
        return cls(
            status=response.status_code,
            response=response.json(),
            is_success=response.is_success,
            is_from_cache=False,
            auth=auth,
        )

    @classmethod
    def _from_cache(cls, data: dict = None, auth: Any = None):
        return cls(
            status=200,
            response=data,
            is_success=True,
            is_from_cache=True,
            auth=auth,
        )

# %% ../nbs/client/client.ipynb 10
def get_cache(
    json_cache_path: str,
    debug_api: bool = False,
) -> Union[dict, None]:
    """function for getting cached data from json file"""

    json_data = None
    try:
        with open(json_cache_path, "r", encoding="utf-8") as file:
            json_data = json.load(file)

    except (FileNotFoundError, json.JSONDecodeError) as e:
        json_data = None

    if json_data:
        if debug_api:
            print(f"ðŸš€ Using cached data in {json_cache_path}")

    return json_data


def update_cache(json_cache_path: str, json_data: dict):
    with open(json_cache_path, "w", encoding="utf-8") as file:
        json.dump(json_data, file)

    return True

# %% ../nbs/client/client.ipynb 14
def prepare_fetch(
    url: str,
    params: dict = None,
    auth: Auth = None,
    headers: dict = None,
    body: dict = None,
):
    """base function to prepare a fetch operation"""

    headers = headers or {}

    if auth:
        headers = {**auth.get_auth_headers(), **headers}

    return headers, url, params, body

# %% ../nbs/client/client.ipynb 15
async def get_data(
    url: str,
    method: str,
    client: httpx.AsyncClient,
    json_cache_path: str,
    is_ignore_cache: bool = False,
    headers: dict = None,
    params: dict = None,
    body: dict = None,
    auth: any = None,
    parent_class: str = None,
    debug_api: bool = False,
) -> Any:
    if not is_ignore_cache:
        json_data = get_cache(json_cache_path=json_cache_path, debug_api=debug_api)

        if json_data:
            return ResponseGetData._from_cache(data=json_data, auth=auth)

    headers, url, params, body = prepare_fetch(
        url=url,
        params=params,
        auth=auth,
        headers=headers,
        body=body,
    )

    if debug_api:
        print(
            {
                "headers": headers,
                "url": url,
                "params": params,
                "body": body,
                "cache_file_path": json_cache_path,
                "debug_api": debug_api,
                "parent_class": parent_class,
            }
        )

    client = client or httpx.AsyncClient()

    if method.upper() == "GET":
        res = await client.get(
            url=url, headers=headers, params=params, follow_redirects=True
        )

    rgd = ResponseGetData._from_httpx(res, auth=auth)

    if rgd.is_success:
        update_cache(json_cache_path=json_cache_path, json_data=rgd.response)

    return rgd

# %% ../nbs/client/client.ipynb 18
# async def fetch_post(client: httpx.AsyncClient):
#     data_to_post = {"key": "value"}
#     response = await client.post(f"{BASE_URL}/post", json=data_to_post)
#     return response.json()


# async def fetch_put(client: httpx.AsyncClient):
#     data_to_put = {"key": "updated_value"}
#     response = await client.put(f"{BASE_URL}/put", json=data_to_put)
#     return response.json()


# async def fetch_delete(client: httpx.AsyncClient):
#     response = await client.delete(f"{BASE_URL}/delete")
#     return response.json()
